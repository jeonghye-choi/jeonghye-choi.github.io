{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## Constructor\n\n초기화를 하지 않으면 -> 문제가 발생할 수 있다.\n\n생성자는 두 개의 단계로 구성되어 있는데,\n\n1. 전역변수, 지역변수, 힙 등 객체를 위한 메모리 공간 할당\n\n2. 메모리 공간을 초기화하기 위한 초기화 함수가 자동으로 호출된다.\n\n따라서, 객체가 생성될 때, 초기상태가 있어야한다.\n\n- 구조\n\n  constructor는 객체가 생성될 때 자동 호출.\n\n  클래스와 이름이 같고 return type이 없다.\n\n```cpp\nclass Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\npublic:\n    Rectangle(int x1, int y1, int x2, int y2){\n        leftTopX = x1;\n        leftTopY = y1;\n        rightBottomX = x2;\n        rightBottomY = y2;\n    }\n}\n```\n\n- 생성자 호출\n\n  ```cpp\n  int main(){\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      Ractangle r1(x1, y1, x2, y2);  // 생성자(constructor) 호출\n\n      int x3, y3, x4, y4;\n      r1.getLeftTop(x3, y3);\n      r1.getRightBottom(x4, y4);\n\n      Rectangle* const pR = new Rectangle(x3, y3, x4, y4);   // 생성자 호출\n\n      cout << endl r1.getArea() << '\\t' << pR->getArea() << endl;\n\n      delete pR;\n  }\n  ```\n\n### Constructor overloading\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Point {\npublic:\n    int x,  y;\n    Point(int x, int y) {\n        this->x = x;\n        this->y = y;\n    }\n};\n\nclass Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\npublic:\n    // 1번 생성자 (int type 4개)\n    Rectangle(int x1, int  y1, int x2=0, int y2=0){\n        set(x1, y1, x2, y2);\n    }\n\n    // 2번 생성자 (int type 2개) --> 불필요! : 위에처럼 default를 인자에 주면 된다.\n    // => 같은 생성자를 쓰게되면 : ERROR 'Call to constructor of 'Rectangle' is ambiguous.\n\n    //Rectangle(int x, int y) {\n    //    set(x, y, 0, 0);\n    //}\n\n    // 3번 생성자 (const reference 2개)\n    Rectangle(const Point& leftTop, const Point& rightBottom=Point(0,0)){\n        set(leftTop.x, leftTop.y, rightBottom.x, rightBottom.y);\n    }\n\n    // 4번 생성자 (const reference 1개) --> 불필요 : 위에처럼 default를 인자에 주면 된다.\n    // => 같은 생성자를 쓰게되면 : ERROR 'Call to constructor of 'Rectangle' is ambiguous.\n\n    //Rectangle(const Point& leftTop){\n    //    set(leftTop.x, leftTop.y, 0,0);\n    //}\n\n    void set(int x1, int y1, int x2, int y2){\n        leftTopX = x1;\n        leftTopY = y1;\n        rightBottomX = x2;\n        rightBottomY = y2;\n    }\n};\n\nint main(){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    Rectangle r1(x1, y1, x2, y2);\n\n    Rectangle* const pR2 = new Rectangle(x1+10, y1+10);\n\n    Point p1(10, 10), p2(20, 20);\n\n    Rectangle r3(p1, p2);\n\n    Rectangle* const pR4 = new Rectangle(Point(30, 30));\n\n    delete pR2;\n    delete pR4;\n}\n```\n\n### Default constructor\n\n인자없이 생성자 호출, 각 인자에 default 값이 있는 경우\n\n- default constructor\n\n  ```cpp\n  class Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\n  public:\n    Rectangle(){ set(0,0,0,0); }\n  };\n  ```\n\n- 각 인자에 default값 있는 경우\n\n  ```cpp\n  class Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\n  public:\n    Rectangle(int x1=0, int y1=0, int x2=0, int y2=0){\n        set(x1, y1, x2, y2);\n    }\n  };\n  ```\n\n  ```cpp\n  // main 함수\n    int main(){\n        Rectangle r1;\n        // Rectangle r1() <-- 사용X\n        // Rectangle 타입의 함수 r1() 선언으로 해석될 수 있음!\n\n        r1.print();\n\n        Rectangle r2;\n        r2.print();\n\n        Rectangle* const pR = new Rectangle();\n        pR -> print();\n\n        delete pR;\n    }\n\n  ```\n\n생성자가 정의되어 있지 않으면 -> compiler가 생성자 자동 생성한다.\n\n```cpp\nclass Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\npublic:\n    // 생성자 없음\n    ...\n    void set(int x1, int y1, int x2, int y2){...}\n}\n\n\nint main(){\n    Rectangle r1;\n    r1.print()   // garbage값이 나옴\n\n    Rectangle* const pR = new Rectangle();\n    pR->print();   // 0,0,0,0\n    delete pR;\n\n    Rectangle r2 = Rectangle();\n    r2.print();   // 0,0,0,0\n\n    Rectangle r3{};   // since C++11\n    r3.print();\n}\n```\n\n### Member initializer\n\n- 객체 배열 초기화\n\n  ```cpp\n  class Point {\n  public:\n      int x, y;\n      Point(int _x=0, int _y=0)\n      : x(_x), y(_y) {}\n  };\n\n  class Rectangle{\n\n  public:\n      ...\n      Rectangle(){...}  // default 생성자\n\n      Rectangle(int x1, int y1, int x2, int y2){ ... }\n\n      Rectangle(int x, int y) { set(x, y, 0, 0); }\n\n      Rectangle(const Point& leftTop, const Point& rightBototm){ ... }\n\n      Rectangle(const Point& leftTop){ ... }\n  }\n\n  int main(){\n      Rectangle rectangles1[10];\n\n      Rectangle rectangles2[] = {\n          Rectangle(),   // default 생성자\n          Rectangle(10,10,20,20),\n          Rectangle(10,10),\n          Rectangle(Point(10,10), Point(20,20)),\n          Rectangle(Point(10,10))\n      };\n\n      int rectNo;\n      cin >> rectNo;\n      Rectangle* const pRectangle1 = new Rectangle[rectNo];\n      delete [] pRectangles1;\n\n      Rectangle* const pRectangle2 = new Rectangle[rectNo]{\n          Rectangle(10,10,20,20),\n          Rectangle(10,10)\n      };\n      delete [] pRectangle2;\n  }\n  ```\n\n- 멤버 초기화\n\n  - 위치\n\n    ```cpp\n    class Rectangle {\n        int leftTopX, leftTopY;\n        int rightBottomX, rightBottomY;\n    public:\n        Rectangle(int x1=0, int y1=0, int x2=0, int y2=0)\n        : leftTopX(x1), leftTopY(y1)  // 멤버 초기화 목록\n        {\n            // body: 함수 본문\n            rightBottomX = x2;\n            rightBottomY = y2;\n        }\n    }\n    ```\n\n- 멤버 객체(Member Object) 초기화\n\n  데이터 멤버 초기화는 **\":\"** 사용.\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n\n  class Point {\n      int x,y;\n  public:\n      Point(int x=0, int y=0){\n          this->x = x;\n          this->y = y;\n      }\n  };\n\n  class Rectangle {\n      Point rightBottom, leftTop;\n  public:\n      // 1번 생성자\n      Rectangle(const Point& p1, const Point&  p2=Point(0,0))\n      :leftTop(p1), rightBottom(p2){\n          cout << \"1번 생성자\" << endl;\n      }  // member initializer\n      // 만약 rightBottom(p2)이 없다면(멤버를 초기화하지 않았다면) -> rightBottom() 즉, 기본 생성자를 호출할 거다.\n\n      // 2번 생성자\n      Rectangle(int x1, int y1, int x2=0, int y2=0)\n      :leftTop(x1, y1), rightBottom(x2, y2){\n          cout << \"2번 생성자\" << endl;\n      }\n\n      // 3번 생성자\n      Rectangle() // 생략가능함! default constructor를 호출하기때문에.\n      // :leftTop(), rightTop() <-- 기본생성자 호출\n      {\n          cout << \"3번 생성자: default constructor\" << endl;\n      }\n\n  };\n\n  int main(){\n      cout << \"\\n\" << \"Rectangle r1;\" << endl;\n      Rectangle r1;\n\n      Point p;\n\n      cout << \"\\n\" << \"Rectangle r2(p, p);\" << endl;\n      Rectangle r2(p, p);\n\n      cout << \"\\n\" << \"Rectangle r3(p);\" << endl;\n      Rectangle r3(p);\n\n      cout << \"\\n\" << \"new Rectangle(100, 200);\" << endl;\n      Rectangle* const pR4 = new Rectangle(100, 200);\n\n      cout << \"\\n\" << \"new Rectangle(100);\" << endl;\n      Rectangle* const pR5 = new Rectangle(100);\n\n\n      delete pR4;\n      delete pR5;\n  }\n  ```\n\n  ```cpp\n  // 실행결과\n  Rectangle r1;\n  3번 생성자: default constructor\n\n  Rectangle r2(p, p);\n  1번 생성자\n\n  Rectangle r3(p);\n  1번 생성자\n\n  new Rectangle(100, 200);\n  2번 생성자\n\n  new Rectangle(100);\n  1번 생성자\n  ```\n\n- member Initializer 용도\n\n  객체, const, reference는 모두 initializer로 초기화 해야한다!\n\n  ```cpp\n  #include <string>\n  #include <vector>\n  using namespace std;\n\n  enum Grade { FRESH=1, SOPHOMORE, JUNIOR, SENIOR };\n\n  class Student;\n\n  class School {\n      const string name;  // const 멤버는 반드시 member initializer로 초기화 해야함\n      vector<Student*> students;   // 멤버객체는 반드시 member initializer로 초기화 해야함\n      float budget;\n  public:\n    School(const string& _name, int size)\n    : name(_name), Students(size)\n    { budget=0; }  // budget member initializer로 초기화 가능:)\n  }\n\n  class Student {\n      string name;\n      Grade grade;\n      const School& school;   // reference 멤버는 반드시 member initializer로 초기화 해야함.\n  public:\n      Student(const School& _school, const string& _name=\"\")\n      :school(_school), name(_name)\n      { grade = FRESH; }\n  };\n  ```\n\n### Copy constructor\n\n셍성자의 인자가 자기 자신이다.\n\n그래도 받으면 overhead가 크기 때문에, &(reference)해서 overhead 피하기!\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Point {\n    int x, y;\npublic:\n    Point(int x=0, int y=0) {  // 일반 생성자\n        this->x = x;\n        this->y = y;\n    }\n    Point(const Point& pt){  // 복사 생성자\n        // 인자로 들어온 Point값을 자기자신의 값으로 정하는 것 (= 인자의 Point를 복사^^)\n        x = pt.x;\n        y = pt.y;\n    }\n    int getX() const {\n        return x;\n    }\n    int getY() const {\n        return y;\n    }\n};\n\nPoint readPoint(){\n    int x, y;\n    cin >> x >> y;\n    return Point(x,y);\n}\n\nvoid print(const Point pt){\n    // pt는 print()함수 내부 stack이 잡힌다. 즉, 참조가 아니기 때문에 \"call by value\"\n    // pt2가 pt로 전덜되어야한다(복사)\n    // 이때, copy constructor 호출\n    cout << pt.getX() << \", \" << pt.getY() << endl;\n}\n\nint main(){\n    Point pt1;  //일반 생성자\n\n    pt1 = readPoint();  // return Point(x,y)로 만들어진 객체를 복사!해서 pt1에 넣는다.\n    Point pt2(pt1);  // 복사생성자 호출 pt1 복제 -> pt2\n    print(pt2);\n}\n```\n\n복사 생성자(copy constructor)가 명시되지 않았다면 컴파일러가 복사생성자를 자동으로 생성한다.\n\n```cpp\n// 자동을 생성된 복사 생성자\nPoint(const Point& pt) { x=pt.x; y=pt.y }\n```\n\ncompiler가 자동으로 copy constructor를 만들어주는데 굳이 정의해야할까??\n\n=> 아래 예시 참고\n\n```cpp\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int DEFAULT_MAX_SIZE = 10;\n\nclass MyStack {\n    char* const items;   // 포인터\n    int top;\n    const int maxSize;\npublic:\n    MyStack(int _maxSize=DEFAULT_MAX_SIZE)\n    : maxSize(_maxSize), items(new char[_maxSize]) {\n        top = 0;\n    }\n    MyStack(const char* const str)\n    : maxSize(strlen(str) + DEFAULT_MAX_SIZE), items(new char[strlen(str) + DEFAULT_MAX_SIZE]){\n        for (int i=0; i<strlen(str); i++){\n            items[i] = str[i];\n            top = strlen(str);\n        }\n    }\n    void push(char c) {items[top++] = c;}\n    char pop(){ return items[--top]; }\n    void print() const {\n        for(int i=0; i<top; i++){\n            cout << items[i];\n        }\n        cout << endl;\n    }\n};\n\nint main() {\n    MyStack st1(\"ABC\");    // not 'ABC'\n    MyStack st2(st1);   // defualt copy constructor invoked\n\n    st2.pop();\n    st2.push('D');\n    st2.print();  // ABD\n\n    st1.print();   // ABD not ABC  <-- shallow copy\n}\n```\n\n- strlen()\n\n  const char\\* 타입의 문자열을 받아서 해당 문자열의 길이를 반환하는 함수\n\n  원형: size_t strlen(const char\\* str);\n\n- 문자 vs 문자열\n\n  문자: 단 하나의 문자 -> ''(작은 따옴표)\n\n  문자열: 문자들의 모임 -> \"\"(큰 따옴표)\n\n위의 예시에서 st1이 st2의 변형에 영향을 받은 것을 알 수 있다.\n\n이는 포인터가 가리키는 대상이 같기 때문이다. (주소를 가리키고 있기 때문에)\n\n![](mystack.jpeg)\n\n따라서, 우리가 원하는 복사가 일어나기 위해서는 명시적으로 copy constructor 를 정의해야한다.\n\n```cpp\nMyStack(const MyStack& another)\n: top(another.top), maxSize(another.maxSize), items(new char[another.maxSize]){\n    for (int i=0; i<top; i++){\n        items[i] = another.items[i];\n    }\n}\n```\n\n## Destructor\n\nconstructor와 반대로 객체가 소멸할 때 호출된다.\n\n대부분의 클래스들이 생성자에 의해 할당된 메모리를 사용하고, 소멸자로 인해 회수된다.\n\n(new -> delete)\n\n- 구조\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n\n  class Point {\n      int x, y;\n  public:\n      Point(int x=0, int y=0){\n          this->x = x;\n          this->y = y;\n          cout << \"\\tPoint\";\n          print();\n          cout << \" constructor\" << endl;\n      }\n      ~Point(){\n          cout << \"\\tPoint \";\n          print();\n          cout << \" destructed.\" << endl;\n      }\n      void print() const {\n          cout << \"(\" << x << \",\" << y << \")\";\n      }\n  }\n  ```\n\n- 예시\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n\n  class Point {\n      int x, y;\n  public:\n      Point(int x=0, int y=0){\n          this->x = x;\n          this->y = y;\n          cout << \"\\tPoint\";\n          print();\n          cout << \" constructed.\" << endl;\n      }\n      ~Point(){\n          cout << \"\\tPoint \";\n          print();\n          cout << \" destructed.\" << endl;\n      }\n      void print() const {\n          cout << \"(\" << x << \", \" << y << \")\";\n      }\n  };\n\n  Point gP(100, 100);\n\n  int main(){\n      cout << \"P1\\n\";\n      Point p1;\n\n      Point* pP2;\n      {\n          cout << \"\\nP2\\n\";\n\n          Point p3(3,3);\n          cout << \"\\nP3\\n\";\n          pP2 = new Point(2,2);\n      }\n      delete pP2;\n  }\n  ```\n\n  ```cpp\n  // 출력결과\n       Point(100, 100) constructed.\n  P1\n      Point(0, 0) constructed.\n  P2\n      Point(3, 3) constructed.\n  P3\n      Point(2, 2) constructed.\n      Point (3, 3) destructed.  //\n      Point (2, 2) destructed.  //\n      Point (0, 0) destructed.  //\n      Point (100, 100) destructed.  //\n  ```\n\n  본인이 정의된 블락을 벗어나면 소멸된다.\n\n- 멤버 객체의 소멸\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n\n  class Point {\n      int x,y;\n  public:\n      Point(int x=0, int y=0){\n          this->x = x;\n          this->y = y;\n          cout << \"\\tPoint \";\n          print();\n          cout << \" constructed.\" << endl;\n      }\n      ~Point(){\n          cout << \"\\tPoint \";\n          print();\n          cout << \" destructed.\" << endl;\n      }\n      void print() const {\n          cout << \"(\" << x << \",\" << y << \")\";\n      }\n  };\n\n  class Rectangle {\n      Point rightBottom, leftTop;\n  public:\n      Rectangle(const Point& p1, const Point& p2=Point(0,0))\n      :leftTop(p1), rightBottom(p2){\n          cout << \"Rectangle: \";\n          print();\n          cout << \" constructed.\" << endl;\n      }\n      Rectangle(int x1, int y1, int x2=0, int y2=0)\n      : leftTop(x1, y1), rightBottom(x2, y2){\n          cout << \"Rectangle: \";\n          print();\n          cout << \" constructed.\" << endl;\n      }\n      Rectangle(){\n          cout << \"Rectangle: \";\n          print();\n          cout << \" constructed.\" << endl;\n      }\n      ~Rectangle(){\n          cout << \"Rectangle: \";\n          print();\n          cout << \" destructed.\" << endl;\n      }\n      void print() const {\n          leftTop.print();\n          rightBottom.print();\n      }\n  };\n\n  int main(){\n      Point p(2,2);\n      Rectangle r2(p);\n  }\n  ```\n\n  ```cpp\n  // 실행결과\n      Point (2,2) constructed.\n      Point (0,0) constructed.\n  Rectangle: (2,2)(0,0) constructed.\n      Point (0,0) destructed.\n  Rectangle: (2,2)(0,0) destructed.\n      Point (2,2) destructed.\n      Point (0,0) destructed.\n      Point (2,2) destructed.\n  ```\n\n- 소멸자의 역할\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n\n  class CharStack {\n      int size;\n      int top;\n      char* const s;\n  public:\n      CharStack(int _size)\n      :size(_size), s(new char[_size]) {\n          top = 0;\n          cout << \"constructor invoked for Stack![\" << size << \"]\" << endl;\n      }\n      CharStack(const CharStack& another)\n      :size(another.size), top(another.top), s(new char[another.size]){\n          for(int i=0; i<=top; i++){\n              s[i] = another.s[i];\n          }\n      }\n      ~CharStack(){\n          delete [] s;  // CharStack이 생길때 마다 힙에 s만큼의 메모리가 할당된다. 따라서 소멸될때 생성한 s포인터들을 모두 없애야한다.\n          cout << \"destructor invoked for Stack[\" << size << \"]\" << endl;\n      }\n  };\n\n  int main(){\n      CharStack cs1(100);   // main이 끝나도 자동으로 소멸되지 않는다\n      // => main이 끝날때 소멸자가 호출되는데, 그때 소멸시켜줘야한다. (cs2의 경우도 마찬가지)\n      for (int i=0; i<10; i++){\n          CharStack cs2(100);\n      }\n  }\n  ```\n\n  ![](charstack.jpeg)\n\n  ```cpp\n  int main(){\n      for (int i=0; i<1000; i++){\n          CharStack cs(1000);\n          ...\n          // (1000 + 8) leaked\n      } // 1000 * (1000 + 8) leaked\n  }\n  ```\n\n## 생성자/소멸자 호출 순서\n\n```cpp\nclass Rectangle {\n    Point rightBottom;\n    Point leftTop;\npublic:\n    Rectangle(int x1, int y1, int x2=0, int y2=0)\n    : leftTop(x1, y1), rightBottom(x2, y2)\n    {...}\n\n    ~Rectangle(){...}\n}\n```\n\n- **Rectangle 생성시**\n\n  1. rightBototm\n\n  2. leftTop\n\n  3. Rectangle() 본문\n\n  => 초기화 순서X, 데이터멤버 정의 순서대로!\n\n- **Rectangle 소멸시**\n\n  1. ~Rectangle()\n\n  2. leftToop\n\n  3. rightBottom\n\n  소멸될 때는, 생성될 때의 반대로 소멸됨.\n\n## 예시\n\nString 클래스 직접 만들기\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass MyString {\n    char* str;\n    int size;\npublic:\n    MyString(){\n        str = NULL;\n        size = 0;\n    }\n    MyString(const char* string)\n    :size(strlen(string)), str(new char[strlen(string)]){\n        for (int i=0; i != strlen(string); i++){\n            str[i] = string[i];\n        }\n    }\n    //copy constructor\n    MyString(const MyString& another)\n    :size(another.size), str(new char[another.size]){\n        for(int i=0; i<size; i++){\n            str[i] = another.str[i];\n        }\n    }\n    ~MyString(){\n        delete [] str;\n    }\n    void print(){\n        for (int i=0; i<size; i++){\n            cout << str[i];\n        }\n        cout << endl;\n    }\n    void set(const int& index, const char& c){\n        str[index] = c;\n    }\n    int length(){\n        return size;\n    }\n    char at(int& index){\n        return str[index];\n    }\n};\n\nint main(){\n    MyString str1(\"ABC\");\n    str1.print();\n\n    {\n        MyString str2(str1);\n        str2.set(0,'D');\n        str2.print();\n    }\n    str1.print();\n\n    for (int i=0; i<str1.length(); i++){\n        cout << str1.at(i);\n    }\n}\n\n```\n\n```cpp\n// 실행결과\nABC\nDBC\nABC\nABC\n```\n","excerpt":"Constructor 초기화를 하지 않으면 -> 문제가 발생할 수 있다. 생성자는 두 개의 단계로 구성되어 있는데, 전역변수, 지역변수, 힙 등 객체를 위한 메모리 공간 할당 메모리 공간을 초기화하기 위한 초기화 함수가 자동으로 호출된다. 따라서, …","fields":{"slug":"/cppClasses_11/"},"frontmatter":{"date":"Apr 16, 2021","title":"c++ Classes, Constructors and Destructor","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[http://tomcat.apache.org/](http://tomcat.apache.org/)\n\n위 사이트에 접속해서 tomcat을 다운받는다.\n\n### 1. 원하는 버전을 선택\n\n![](version.png)\n\n<br/>\n\n### 2. Core에 **\"tar.gz(pgp, sha512)\"** 클릭해서 다운받기\n\n![](targzfile.png)\n<br/>\n\n### 3. 다운받은 파일을 압축해제하고, 원하는 디렉토리로 옮깁니다.\n\n(저는 바탕화면에 옮겼어요!)\n<br/>\n\n### 4. 터미널에 해당 명령어를 입력해줍니다.\n\n```terminal\nsudo mkdir -p /usr/local\n\nsudo mv ~/Desktop/<압축해제한 폴더명> /usr/local\n\nsudo rm -f ~/Library/Tomcat\n\nsudo ln -s /usr/local/<압축해제한 폴더명> /Library/Tomcat\n\nsudo chown -R <맥북 user id> /Library/Tomcat\n\nsudo chmod +x /Library/Tomcat/bin/*.sh\n```\n\n- 맥북 user id 확인하기 (터미널에 아래 명령어 입력!)\n\n```terminal\necho $USER\n```\n\n<br/>\n\n### 5. 톰캣 실행\n\n```terminal\nsudo /Library/Tomcat/bin/startup.sh\n```\n\n**http://localhost:8080** 주소로 들어가면,\n\n![](localhost8080.png)\n<br/>\n\n#### 발생할 수 있는 에러\n\n- The operation couldn’t be completed. Unable to locate a Java Runtime.\n\n  java를 다운받으면 된다.\n\n  [http://www.java.com](http://www.java.com)\n\n  위 사이트에 접속해서 다운받아준다.\n\n  ![](java.png)\n\n  ![](javadownload.png)\n\n  설치후 다시 실행하면\n\n  ```terminal\n  % sudo /Library/Tomcat/bin/startup.sh\n\n  Using CATALINA_BASE:   /Library/Tomcat\n  Using CATALINA_HOME:   /Library/Tomcat\n  Using CATALINA_TMPDIR: /Library/Tomcat/temp\n  Using JRE_HOME:        /Library/Internet Plug-Ins/JavaAppletPlugin.plugin/Contents/Home\n  Using CLASSPATH:       /Library/Tomcat/bin/bootstrap.jar:/Library/Tomcat/bin/tomcat-juli.jar\n  Using CATALINA_OPTS:\n  Tomcat started.\n  ```\n\n  **http://localhost:8080** 주소로 들어가면 끝!\n\n<br/>\n\n### 6. 톰캣 서버 종료\n\n```terminal\nsudo /Library/Tomcat/bin/shutdown.sh\n```\n\n<br/>\n\n### 참고자료\n\n[Junseo Kim's velog](https://velog.io/@max9106/Mac-apache-tomcat%ED%86%B0%EC%BA%A3-%EC%84%A4%EC%B9%98-l0k4zt4f3c)\n","excerpt":"http://tomcat.apache.org/ 위 사이트에 접속해서 tomcat을 다운받는다. 1. 원하는 버전을 선택  2. Core에 \"tar.gz(pgp, sha512)\" 클릭해서 다운받기 \n 3. 다운받은 파일을 압축해제하고, 원하는 디렉토리…","fields":{"slug":"/MacTomcat/"},"frontmatter":{"date":"Apr 14, 2021","title":"Mac, apache tomcat(톰캣) 설치","tags":["mac"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n[https://www.eclipse.org/downloads/packages/](https://www.eclipse.org/downloads/packages/)\n\n위 사이트에 접속해서 설치하기\n\n### 1. package 다운로드\n\n- Eclipse IDE for Java Developers > macOS 클릭!\n\n  ![](eclipseIDEdown.png)\n\n  ![](download.png)\n\n### 2. 설치!\n\n![](application.png)\n\n![](launch.png)\n\n![](complete.png)\n","excerpt":"https://www.eclipse.org/downloads/packages/ 위 사이트에 접속해서 설치하기 1. package 다운로드 Eclipse IDE for Java Developers > macOS 클릭!   2. 설치!","fields":{"slug":"/MacEclipseEE/"},"frontmatter":{"date":"Apr 14, 2021","title":"Mac, Eclipse IDE 설치","tags":["mac"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## {} 괄호를 이용한 초기화 가능\n\n```cpp\nclass Array {\n    int myData[5];\npublic:\n    Array()\n    :myData{1,2,3,4,5} {};   //{} 괄호를 이용해 myData 초기화\n};\n\nclass MyClass {\npublic:\n    int x;\n    double y;\n};\n\nclass MyClass2 {\n    int x;\n    double y;\npublic:\n    MyClass2(int first, double second)\n    :x{first}, y{second}{};\n}\n\nint main(){\n    Array arr;\n\n    // public attributes를 사용한 초기화\n    MyClass myClass1{2021, 4.10};\n    MyClass myClass2 = {2021, 4.10};\n\n    // constructor를 사용한 초기화 <-- 생성자 추천!!\n    MyClass2 myClass3{2021, 4.10};\n    MyClass2 myClass4 = {2021, 4.10};\n}\n\n```\n\n## 클래스 멤버 초기화 가능\n\n```cpp\nclass C{\n    int x;\npublic:\n    C()\n    :x(7){}\n};\n```\n\n```cpp\nclass C{\n    int x=7;  // class member (직접) 초기화\npublic:\n    C();\n};\n```\n\n### 사용가능한 표현\n\n- =(equal sign)\n\n- 괄호(){}\n\n  ```cpp\n  class C {\n      double d=0;\n      string s(\"abc\");\n      char * p {nullptr};\n      int y[5] {1,2,3,4};\n  public:\n      C();\n  };\n  ```\n\n  ```cpp\n  class C {\n      double d;\n      string s;\n      char * p;\n      int y[5];\n  public:\n      C()\n      : d(0.0), s(\"abc\"), p(nullptr), y{1,2,3,4}{}\n  };\n  ```\n","excerpt":"{} 괄호를 이용한 초기화 가능 클래스 멤버 초기화 가능 사용가능한 표현 =(equal sign) 괄호(){}","fields":{"slug":"/cppClasses_9/"},"frontmatter":{"date":"Apr 10, 2021","title":"c++ Classes, New features on classes since c++11","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\nthis : 객체 자신을 가리키는 pointer\n\n특별히 선언하지 않아도 컴파일러에 의해 자동으로 정의되어 사용된다.\n\n## Example1: 인자와 데이터멤버 구분\n\n기존엔 \"\\_\" 를 이용해서 인자와 데이터멤버를 구분했다. this를 통해 데이터 멤버를 가리키게 할 수 있다!\n\n즉, 데이터멤버와 같은 이름의 인자 사용가능!\n\n```cpp\n// Rectangle.h\n#ifndef Rectangle_h\n#define Rectangle_h\nclass Rectangle{\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\npublic:\n    ...\n}\n\nvoid setLeftTopX(const int leftTopX){\n    this->leftTopX = leftTopX; // this->leftTopX는 private에 있는 데이터멤버를 가리킴.\n}\nvoid setLeftTopY(const int leftTopY){\n    this->leftTopY = leftTopY;\n}\nvoid setRightBottomX(const int rightBottomX){\n    this->rightBottomX = rightBottomX;\n}\nvoid setRightBottomYX(const int rightBottomY){\n    this->rightBottomY = rightBottomY;\n}\n#endif\n```\n\n## Example2: 자신의 객체 그 자체!\n\n```cpp\n// Rectangle.h\n#ifndef Rectangle_h\n#define Rectangle_h\nclass Rectangle {\npublic:\n    Rectangle* copy()const{\n        Rectangle* r = new Rectangle;\n        r->setLeftTopX(getLeftTopX());\n        r->setLeftTopY(getLeftTopY());\n        r->setRightBottomX(getRightBottomX());\n        r->setRightBottomY(getRightBottomY());\n        return r;\n    }\n    // 위의 copy()를 this를 사용해서 아래와 같이 정의할 수 있다.\n    Rectangle* copy()const {\n        return new Rectangle(*this);\n        // this는 포인터다. 자신의 객체값을 그대로 전달!\n        // 동일한 타입의 객체를 만들어냄 => copy constructor 호출.\n    }\n    bool isEqual(const Rectangle& r)const {\n        return leftTopX == r.leftTopX\n            && leftTopY == r.leftTopY\n            && rightBottomX == r.rightBottomX\n            && rightBottomY == r.rightBottomY;\n    }\n};\n#endif\n```\n\n```cpp\n// main.cpp\n#include <iostream>\n#include <cassert>\n#include \"Rectangle.h\"\nusing namespace std;\n\nint main(){\n    Rectangle r;\n    r.set(0, 0, 100, 200);\n\n    Rectangle* pR = r.copy();\n    // r이라는 Rectangle과 똑같은 Rectangle을 만들어서 그에대한 pointer리턴!\n    assert(pR->isEqual());\n    // assert는 디버깅을 위한 에러검출 함수! ()안의 조건을 만족해야함! 그렇지 않으면 에러를 띄워 알려준다:)\n\n    delete pR;  //  new 연산자를 사용해서 만든 개체에 대해 삭제!\n}\n```\n\n## Example3:\n\n```cpp\n// main.cpp\n#include <iostream>\n#include \"Rectangle.h\"\nusing namespace std;\n\nint main(){\n    Rectangle r;\n    r.set(0, 0, 100, 200);\n\n    cout << r.moveBy(10,10).print() << endl;  // 10 10 110 210\n    // 이동후->print : moveBy가 Rectangle을 호출해야지 print가능\n\n    cout << r.moveBy(10,10).moveBy(10,10).print() << endl;\n    // expected: 30 30 130 230, but actually 20 20 120 220\n    // moveBy가 Rectangle객체로 return 하는지, reference로 return 하는지에 따라 결과가 달라질 수 있다.\n    // => moveBy후 또 moveBy: 원하는 결과를 위해서는 reference로 reture해야한다!\n\n    r.moveBy(10,10).print();\n    cout << r.moveBy(10,10).print().getArea() << endl;\n}\n```\n\n따라서,\n\n```cpp\n// Rectangle.h\n#ifndef Rectangle_h\n#define Rectangle_h\nclass Rectangle {\npublic:\n    ...\n    Rectangle& moveBy(int deltaX, int deltaY);\n    const Rectange& print()const{\n        cout << leftTopX << leftTopY << \"\\t\" << rightBottomX << \"\\t\" << rightBottomY << endl;\n        return *this;\n    }\n    int getArea()const{...}\n}\n\n#endif\n```\n\n```cpp\n#include \"Rectangle.h\"\n\n...\nRectangle& Rectangle::moveBy(int deltaX, int deltaY){\n    // &(reference)를 하지 않는다면, return되는 this는 자신이 아닌 copy가 될 수 있다.\n    setLeftTop(leftTopX+deltaX, leftTopY+deltaY);\n    setRightBottom(rightBottomX+deltaX, rightBottomY+deltaY)\n    return *this;\n}\n```\n","excerpt":"this : 객체 자신을 가리키는 pointer 특별히 선언하지 않아도 컴파일러에 의해 자동으로 정의되어 사용된다. Example1: 인자와 데이터멤버 구분 기존엔 \"_\" 를 이용해서 인자와 데이터멤버를 구분했다. this를 통해 데이터 멤버를 가리…","fields":{"slug":"/cppClasses_7/"},"frontmatter":{"date":"Apr 10, 2021","title":"c++ Classes, this","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n클래스 내부에 클래스 정의\n\n## Example\n\n가능은 하지만, 이럴 필요가 없으면 Point를 nested class로 하지 않는 것이 좋다!\n\n```cpp\nclass Rectangle {\npublic:\n    class Point {\n    public:\n        int x, y;\n        void print()const{ cout << x << \"\\t\" << y; }\n        bool isEqual(const Point& p)const{ return x==p.x && y==p.y; }\n    };\n\n    Point leftTop, rightBottom;\n    void setLeftTop(int x, int y){\n        leftTop.x = x;\n        leftTop.y = y;\n    }\n    void setRightBototm(int x, int y){\n        RightBototm.x = x;\n        RightBototm.y = y;\n    }\n    bool isEqual(const Rectangle& r)const{\n        return leftTop.isEqual(r.leftTop) && rightBottom.isEqual(r.rightBottom);\n    }\n    const Rectangle& print()const{\n        leftTop.print();\n        cout << \"\\t\" << rightBottom.print();\n        return *this;\n    }\n}\n```\n\n```cpp\n//main.cpp\n#include <iostream>\n#include <string>\n#include \"Rectangle.h\"\nusing namespace std;\n\nint main(){\n    Rectangle r1;\n    r1.set(0,0,100,200);\n\n    Rectangle r2;\n    r2.set(10,10,110,210);\n\n    r1.print(); cout << endl;\n    r2.print(); cout << endl;\n\n    string msg = r1.isEqual(r2) ? \"SAME\" : \"DIFFERENT\";\n    cout << msg << endl;\n\n    Rectangle::Point pt; // Rectangle 내부의 Point!\n    //가능은 하지만, 이럴 필요가 없으면 Point를 nested class로 하지 않는 것이 좋다!\n}\n```\n","excerpt":"클래스 내부에 클래스 정의 Example 가능은 하지만, 이럴 필요가 없으면 Point를 nested class로 하지 않는 것이 좋다!","fields":{"slug":"/cppClasses_8/"},"frontmatter":{"date":"Apr 10, 2021","title":"c++ Classes, Nested Classes","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n- node\n\n- 양방향\n\n- 0은 연결된 다음 포인터가 없다는 뜻\n\n```cpp\n// Point 클래스\nclass Point {\n    int x, y;\n    Point* pNext;\npublic:\n    Point(int _x=0, int _y=0, Point* const _pNext=nullptr){\n        x = _x;\n        y = _y;\n        pNext = _pNext;\n    }\n    Point* getNext(){ return pNext; }\n    void setNext(Point* const _pNext){\n        pNext = _pNext;\n    }\n    void print(){\n        cout << x << \",\" << y << endl;\n    }\n};\n```\n\n```cpp\n// SinglyLinkedList 클래스 : Pointer 리스트 관리\nclass SinglyLinkedList {\n    Point* head;  // 첫번째 포인터만 관리하면 됨!\npublic:\n    SinglyLinkedList(){ head = nullptr; }\n    void print() {\n        Point* pPoint = head;\n        while (pPoint != nullptr){\n            pPoint -> print();\n            pPoint = pPoint -> getNext();\n        }\n    }\n    void prepend(Point* const newPoint){ // head 다음 제일 첫 위치에 새로운 Point를 추가!\n        if (head == nullptr){\n            head = newPoint;\n        } else {   // head가 null이 아니면 head가 newPoint를 가리키게 하자!\n            newPoint -> setNext(head);  // newPoint의 다음 node를 head로 함.\n            head = newPoint;    // newPoint가 head가 됨.\n        }\n    }\n    void insertAfter(Point* const prev, Point* const newPoint){\n        assert( prev != nullptr );\n        newPoint->setNext(prev->getNext());\n        prev->setNext(newPoint);\n    }\n    void remove(Point* const toBeRemoved){\n        if ( toBeRemoved == head ){\n            head = head->getNext();\n            return;\n        }\n        Point* pPoint = head;\n        while ( pPoint != nullptr ){\n            if ( pPoint->getNext() == toBeRemoved ){\n                Point* pNextOfToBeRemoved = toBeRemoved->getNext();  // 삭제될 node의 다음 node를 pNextOfToBeRemoved라고 정의.\n                pPoint->setNext(pNextOfToBeRemoved);    // pPoint의 다음 노드로 pNextOfToBeRemoved를 가리킴.\n                break;\n            }\n            pPoint = pPoint->getNext();    // pPoint가 가리키는 node의 다음 noderk toBeRemoved가 될 때를 찾기 위해서.\n        }\n    }\n};\n```\n\n- prepend()\n  ![](singleList.jpeg)\n\n  head가 null이 아닐때,\n\n  1. newPoint의 다음 노드를 head로 함\n\n  2. newPoint를 head로 정의\n\n- insertAfter()\n  ![](singleListInsert.jpeg)\n\n  추가하고 싶은 곳의 previous node를 prev 인자로 전달.\n\n  1. newPoint의 next node로 previous node의 이전의 next node를 가리킴.\n\n  2. previous node의 next node로 newPoint를 가리킴.\n\n- remove()\n  ![](removeList.jpeg)\n","excerpt":"node 양방향 0은 연결된 다음 포인터가 없다는 뜻 prepend()\n head가 null이 아닐때, newPoint의 다음 노드를 head로 함 newPoint를 head로 정의 insertAfter()\n 추가하고 싶은 곳의 previous no…","fields":{"slug":"/cppClasses_5/"},"frontmatter":{"date":"Apr 10, 2021","title":"c++ Classes, 단방향 연결 리스트","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## private and public members\n\n모듈화를 위해서, 중요하지 않은 정보는 숨김.\n\n또한 유지성과 유지성을 위해서 (public한 부분만 이해하면 되기 때문에)\n\n### 구조\n\n```cpp\nclass class_name{\nprivate:\n    data members  // private에 있는 데이터멤버는 클래스 밖에서 접근 불가능\npublic:\n    member functions\n};\n```\n\n### Example\n\n```cpp\nclass Rectangle{\nprivate:\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\n    void setLeftTop(int x, int y){\n        leftTopX = x;\n        leftTopY = y;\n    }\n    void setRightBottom(int x, int y){\n        rightBottomX = x;\n        rightBottomY = y;\n    }\npublic:\n    void set(int x1, int y1, int x2, int y2){\n        setLeftToop(x1, y1);\n        setRightBottom(x2, y2);\n    }\n    void getLeftTop(int& x, int& y)const{\n        x = leftTopX;\n        y = leftTopY;\n    }\n    void getRightBottom(int& x, int& y)const{\n        x = rightBottomX;\n        y = rightBottomY;\n    }\n    int getArea()const{\n        return (rightBottomX-leftTopX)*(rightBottomY-leftTopX);\n    }\n}\n```\n\n```cpp\nint main(){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    Rectangle r1;\n    r1.set(x1, y1, x2, y2);\n    r1.leftTopX = r1.leftTopX + 1   // ERROR: private 접근 불가\n\n    int x3, y3, x4, y4;\n    r1.getLeftTop(x3, y3);\n    r1.getRightBottom(x4, y4);\n\n    Rectangle r2;\n    r2.setLeftTop(x3, y3);  // ERROR : private 접근 불가 -> set사용\n    r2.setRightBottom(x4, y4);  // ERROR : private 접근 불가 -> set사용\n    r2.set(x3, y3, x4, y4);    // OK\n\n    cout << endl << r1.getArea() << \"\\t\" << r2.getArea() << endl;\n}\n```\n\n## friend function and friend class\n\nfriend는 private 임에도 불구하고 외부에 접근을 허용한다.\n\nfriendsms information hiding principle을 위배하기 때문에 최소한의 상황에서 사용권장.\n\n### 가능한 friend forms\n\n- 1 friend non-member function\n\n- 2 friend class\n\n- 3 friend member function\n\n### 1. friend non-member function\n\n#### 구조\n\n```cpp\n// friend 함수\nvoid f(){ ... }\n```\n\n```cpp\nclass SomeClass {\n[private:]\n    전용멤버\n[public:]\n    공용멤버\n    friend void f();\n};\n\n```\n\n#### Example\n\n```cpp\n// Window.h\nclass Window {\nprivate:\n    ...\n    string title;\n    ...\npublic:\n    string getTitle() const;\n    friend void friendOfWindow(const Window&);\n    void nonFriendOfwindow(const Window&);\n};\n```\n\n```cpp\n// WindowMain.cpp\nvoid friendOfWindow(const Window& anWindow){\n    cout << anWindow.title;\n}\nvoid nonFriendOfwindow(const Window& anWindow){\n    cout << anWindow.title;  // ERROR\n    cout << anWindow.getTitle();\n\n}\n```\n\n### 2. Friend Class\n\n#### 구조\n\n```cpp\n// friend 함수\nclass C {\n    멤버함수_1\n    멤버함수_2\n    ...\n    멤버함수_n\n}\n```\n\n```cpp\nclass SomeClass {\n[private:]\n    전용멤버\n[public:]\n    공용멤버\n    friend class C;\n};\n\n```\n\n#### Example1\n\n```cpp\nclass StringNode {\n    string data;\n    StringNode* next {nullptr};\n\n    StringNode(const string& d=\"\")\n    : data(d) {}\n    bool isEqual(const StringNode& n)const{\n        return data == n.data;\n    }\n    friend class StringList;\n}\n```\n\n#### Example2\n\n```cpp\nclass StringList {\n    StringNode* head {nullptr}  //default is private\npublic:\n    StringNode* addNode(const string& data){\n        StringNode* newNode = new StringNode(data);\n        if ( head==nullptr ){ head = newNode; }\n        else {\n            head->next = newNode;\n            head = newNode;\n        }\n        return newNode;\n    }\n    void removeNode(const StringNode* const node){\n        StringNode* cur = head, * prev = nullptr;\n        while ( cur != nullptr ) {\n            if (next->isEqual(*node)){\n                if (prev) {\n                    prve->next = cur->next;\n                } else {\n                    head = cur->next;\n                }\n                delete cur;\n                break;\n            }\n            cur = cur->next;\n        }\n    }\n};\n```\n\n### 3. Friend Member Function\n\n```cpp\nclass StringNode {\nprivate:\n    string data;\n    StringNode* next {nullptr};\npublic:\n    bool isEqual() const;\n    StringNode* getNext() const;\n    void setNext(const StringNode* const);\n    friend void StringList::addNode(const StringNode& node);\n};\n\nclass StringList {\n    StringNode* head {nullptr};\npublic:\n    void addNode(const StringNode& node){\n        StringNode* newNode = new StringNode;\n        newNode->data = node.data;\n        newNode->next = nullptr;\n\n        if (head==nullptr){\n            head = newNode;\n        } else {\n            head->next = newNode;\n            head = newNode;\n        }\n    }\n    void removeNode(const StringNode& node){\n        StringNode* cur = head, * prev = nullptr;\n        while ( cur != nullptr ){\n            if (next->isEqual(node)){\n                if (prev){\n                    prev->setNext(cur->getNext());\n                } else {\n                    head = cur->getNext();\n                }\n\n                delete cur;\n                break;\n            }\n            cur = cur->getNext();\n        }\n    }\n}\n```\n","excerpt":"private and public members 모듈화를 위해서, 중요하지 않은 정보는 숨김. 또한 유지성과 유지성을 위해서 (public한 부분만 이해하면 되기 때문에) 구조 Example friend function and friend class…","fields":{"slug":"/cppClasses_10/"},"frontmatter":{"date":"Apr 10, 2021","title":"c++ Classes, Information Hidiing","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## const member function\n\n```cpp\n// Rectangle.h\n#ifndef Rectangle_h\n#define Rectangle_h\n\nclass Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\n    void setLeftTop(int x, int y){  // 데이터 멤버 수정함 -> const사용불가!\n        leftTopX = x;\n        leftTopY = y;\n    }\n    void setRightBottom(int x, int y){\n        rightBottomX = x;\n        rightBottomY = y;\n    }\npublic:\n    static int allCount;  // 명시만\n\n    Rectangle() { allCount++; }\n    ~Rectangle() { allCount--; }\n\n    static int getAllCount() { return allCount; }   // not const\n    static bool noRectangle() { return allCount == 0; }\n\n    void set(int x1, int y1, int x2, int y2){\n        setLeftTop(x1, y1);\n        setRightBottom(x2, y2);\n    }\n    void getLeftTop(int& x, int& y)const{  //const: 자신의 데이터멤버의 값을 변경하지 않고 읽기만 한다고 명시.\n        x = leftTopX;\n        y = leftTopY;\n    }\n    void getRightBottom(int& x, int& y)const{\n        x = rightBottomX;\n        y = rightBottomY;\n    }\n    int getWidth()const{ return rightBottomX - leftTopX; }\n    int getHeight()const{ return rightBottomY - leftTopY; }\n\n    int getArea()const;  // 명시만\n    void moveBy(int deltaX, int deltaY);  // 명시만\n};\n\n#endif\n```\n\n```cpp\n// Rectangle.cpp\n#include <iostream>\n#include \"Rectangle.h\"\n\nint Rectangle::allCount = 0;\nint Rectangle::getArea()const { return getWidth()*getHeight(); }\nvoid Rectangle::moveBy(int deltaX, int deltaY){\n    setLeftTop(leftTopX + deltaX, leftTopY+deltaY);\n    setRightBottom(rightBottomX + deltaX, rightBottomY + deltaY);\n}\n\n```\n\n```cpp\n// RectangleMain.cpp\n#include <iostream>\n#include \"Rectangle.h\"\nusing namespace std;\n\nvoid readRectangle(Rectangle& r){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    r.set(x1, y1, x2, y2);\n}\n\nvoid printRectangle(const Rectangle& r){\n    int x1, y1, x2, y2;\n    r.getLeftTop(x1, y1);\n    r.getRightBottom(x2, y2);\n    cout << x1 << \"\\t\" << y1 << \"\\t\" << x2 << \"\\t\" << y2 << endl;\n    // r.setLeftTop(0,0); 은 Error 발생 <= const 때문에\n}\n\nint main(){\n    Rectangle r;\n    readRectangle(r);\n    printRectangle(r);\n}\n\n```\n","excerpt":"const member function","fields":{"slug":"/cppClasses_6/"},"frontmatter":{"date":"Apr 09, 2021","title":"c++ Classes, 객체 데이터 멤버","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n다른 클래스의 객체가 자신의 멤버로 사용될 때, 객체 데이터 멤버라고 한다.\n\n## 구조\n\n```cpp\n// Point 클래스\nclass Point {\nprivate:\n  int x;\n  int y;\npublic:\n  Point(int _x=0, int _y=0){    // default값 0\n    x = _x;\n    y = _y;\n  }\n};\n\n// Rectangle 클래스\nclass Rectangle {\nprivate:\n  Point leftTop;    // 다른 클래스의 객체가 자신의 멤버로 사용될 때 => 객체 데이터 멤버\n  Point rightBottom;\npublic:\n  ...\n}\n```\n\n![](objectDataMember.png)\n\n## 객체 데이터 멤버 초기화\n\n```cpp\nRectangle(int x1, int y1, int x2, int y2)\n  : leftTop(x1, y1), rightBottom(x2, y2)    // Point타입의 생성자 호출\n  {}\n```\n\n```cpp\n// main.cpp\nint main(){\n  ...\n  Rectangle r(10, 20, 30, 40);\n}\n```\n\n![](objectDataMember2.png)\n\n## Example: Computer and Monitor\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Monitor {\n    string maker;\n    int price;\npublic:\n    Monitor(const string _maker, const int _price)\n    : maker(_maker){   // maker초기화 (maker는 string객체 -> 멤버 이니셜라이즈 사용)\n        price = _price ;    // price 초기화 (price는 int -> body에서 초기화)\n    }\n    void display(const string& msg){\n        cout << maker << \": \" << msg << endl;\n    }\n    int getPrice(){ return price; }\n};\n\nclass Computer {\n    string maker;    // string 객체를 데이터 멤버로 가짐\n    Monitor monitor;    // Monitor 객체를 데이터 멤버로 가짐\n    int price;\npublic:\n    Computer(const string& _maker, const Monitor& _monitor, const int _price)\n        :maker(_maker), monitor(_monitor){   // maker, monitor는 각각 string, Monitor객체임으로 멤버 이니셜라이즈 이용\n            // 두번째 인자로 넘겨준 Monitor클래스의 samsungMonitor로 초기화\n            price = _price;    // price는 int타입이라서 Computer생성자의 body에 위치\n        }\n    void run(const string& msg){\n        cout << \"Runs on \" << maker << endl;\n        monitor.display(msg);\n    }\n    int getPrice(){ return price; }\n};\n\n\nint main(){\n    Monitor samsungMonitor(\"SamsungMonitor\", 100);\n    Computer samsungPC(\"Samsung\", samsungMonitor, samsungMonitor.getPrice() + 200);\n\n    cout << samsungPC.getPrice() << endl;\n    samsungPC.run(\"Hello C++\");\n}\n\n```\n","excerpt":"다른 클래스의 객체가 자신의 멤버로 사용될 때, 객체 데이터 멤버라고 한다. 구조  객체 데이터 멤버 초기화  Example: Computer and Monitor","fields":{"slug":"/cppClasses_4/"},"frontmatter":{"date":"Apr 09, 2021","title":"c++ Classes, 객체 데이터 멤버","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Static Data member\n\n![](staticDataMember.png)\n\nData member는 Rectangle 객체가 만들어 질때마다 확보되는 공간이다.\n\nr1이 만들어 지면서 Data member가 할당 되고,\n\nr2가 만들어 지면서 또 다른 Data member가 할당 된다.\n\nstatic Data member는 오직 하나만 차지하고 이 하나에만 접근하게 한다.\n\n### Example1\n\n```cpp\n// Rectangle.h\n#ifndef Rectangle_h\n#define Rectangle_h\n\nclass Rectangle {\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\n\n    void setLeftTop(int x, int y){\n        leftTopX = x;\n        leftTopY = y;\n    }\n    void setRightBottom(int x, int y){\n        rightBottomX = x;\n        rightBottomY = y;\n    }\npublic:\n    static int allCount;\n\n    Rectangle(){ allCount++; }   // 생성자: 객체 생성시 자동 호출\n\n    ~Rectangle(){ allCount--; }   // 소멸자: 객체 소멸시 자동 호출\n\n    void set(int x1, int y1, int x2, int y2){\n        setLeftTop(x1, y1);\n        setRightBottom(x2, y2);\n    }\n};\n#endif\n```\n\n```cpp\n// Rectangle.cpp\n#include <iostream>\n#include \"Rectangle.h\"\n\nint Rectangle::allCount = 0;\n```\n\n```cpp\n// RectangleMain.cpp\n#include <iostream>\n#include \"Rectangle.h\"\nusing namespace std;\n\nint main(){\n    Rectangle r1;\n    r1.set(1,1,2,2);\n    cout << Rectangle::allCount << endl;   // 1\n\n    Rectangle r2;\n    r2.set(10,10,20,20);\n    cout << Rectangle::allCount << endl;    // 2\n\n}\n```\n\n### Example2\n\n```cpp\n#include <iostream>\n#include \"Rectangle.h\"\nusing namespace std;\n\nRectangle gRectangle1, gRectangle2;\n\nint main(){\n    cout << Rectangle::allCount << endl;    // 2\n\n    Rectangle r1;\n\n    cout << Rectangle::allCount << endl;    // 3\n\n    for ( int i=0; i<3; i++){\n        Rectangle r;\n        cout << Rectangle::allCount << endl;    // 4\n    }\n\n    Rectangle* pR = new Rectangle;\n    cout << Rectangle::allCount << endl;    // 4\n    delete pR;\n    cout << Rectangle::allCount << endl;    // 3\n}\n```\n\n- Q: for문 안에서는 왜 증가하지 않을까?\n\n- Q: new로 동적할당을 할 때는 왜 증가하지 않을까?\n\n## Static member function\n\nstatic member function은 static data member만 호출할 수 있다.\n\n```cpp\n// Rectangle.h\n#ifndef Rectangle_h\n#define Rectangle_h\n\nclass Rectangle {\n    static int allCount;    // allCount 데이터 멤버는 private함.\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\npublic:\n    // 정적 멤버함수는 정적 데이터 멤버만 호출가능.\n    static int getAllCount(){return allCount;}\n    static bool noRectangle(){return allCount == 0;}\n    Rectangle(){allCount++;}\n    ~Rectangle(){allCount--;}\n};\n\n#endif\n```\n\n```cpp\n// Rectangle.cpp\n#include <iostream>\n#include \"Rectangle.h\"\n\nint Rectangle::allCount = 0;\n\n```\n\n```cpp\n// RectangleMain.cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include \"Rectangle.h\"\nusing namespace std;\n\nint main(){\n    vector<Rectangle*> rectangles;\n\n    do {\n        string command;\n        cin >> command;\n\n        if (command == \"ADD\"){\n            rectangles.push_back(new Rectangle);\n\n        }\n        else if (command == \"DELETE\"){\n            vector<Rectangle*>::iterator head = rectangles.begin();\n            Rectangle* r = *head;\n            delete r;\n            rectangles.erase(head);\n        }else {break;}\n\n        cout << Rectangle::getAllCount() << endl;   // public static member (allCount 데이터멤버 private으로 정의)\n    } while (Rectangle::noRectangle() == false);\n\n    for (vector<Rectangle*>::iterator Iter = rectangles.begin(); Iter != rectangles.end(); Iter++){\n        Rectangle* r = *Iter;\n        delete r;\n    }\n}\n\n```\n","excerpt":"Static Data member  Data member는 Rectangle 객체가 만들어 질때마다 확보되는 공간이다. r1이 만들어 지면서 Data member가 할당 되고, r2가 만들어 지면서 또 다른 Data member가 할당 된다. sta…","fields":{"slug":"/cppClasses_3/"},"frontmatter":{"date":"Apr 09, 2021","title":"c++ Classes, static data member & Static member function","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## Data members and Member function\n\n### 객체의 동적 생성\n\n- 방법1: [] 사용\n\n  ```cpp\n  #include <iostream>\n  #include \"Rectangle.h\"\n  using namespace std;\n\n  int main(){\n      int rectNo;\n      cin >> rectNo;\n      Rectangle* const rectangles = new Rectangle[rectNo];\n\n      for (unsigned int i=0; i<rectNo; i++){\n          cout << \"Enter Rectangle information\" << endl;\n          int x1, y1, x2, y2;\n          cin >> x1 >> y1 >> x2 >> y2;\n          rectangles[i].set(x1, y1, x2, y2);\n      }\n      int totalArea = 0;\n      for (unsigned int i=0; i<rectNo; i++){\n          totalArea += rectangles[i].getArea();\n      }\n\n      delete [] rectangles;\n      cout << \"The total area: \" << totalArea << endl;\n  }\n\n  ```\n\n  ![](newRectangle.png)\n\n- 방법2: 포인터 사용\n\n  (이해가 안됨....ㅠㅜㅠ 공부필요..!!)\n","excerpt":"Data members and Member function 객체의 동적 생성 방법1: [] 사용  방법2: 포인터 사용 (이해가 안됨....ㅠㅜㅠ 공부필요..!!)","fields":{"slug":"/cppClasses_2/"},"frontmatter":{"date":"Apr 09, 2021","title":"c++ Classes, Data members 객체의 동적 생성","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n클래스 = 객체들의 집합\n\n### 구조\n\n```cpp\nclass 클래스이름{\nprivate:\n    데이터 멤버\npublic:\n    멤버 함수\n};\n```\n\n#### Example: Rectangle 클래스\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Rectangle {\nprivate:\n    int leftTopX, leftTopY;\n    int rightBottomX, rightBottomY;\npublic:\n    Rectangle (int x1, int y1, int x2, int y2){\n        set(x1, y1, x2, y2);\n    }\n    void set(int x1, int y1, int x2, int y2){\n        leftTopX = x1;\n        leftTopY = y1;\n        rightBottomX = x2;\n        rightBottomY = y2;\n    }\n    void getLeftTop(int& x, int& y){\n        x = leftTopX;\n        y = leftTopY;\n    }\n    void getRightBottom(int& x, int& y){\n        x = rightBottomX;\n        y = rightBottomY;\n    }\n    int getArea(){\n        return (rightBottomX-leftTopX)*(rightBottomY-leftTopX);\n    }\n};\n\n\nint main(){\n    Rectangle r1(10, 10, 20, 20);\n\n    int x1, y1, x2, y2;\n    r1.getLeftTop(x1, y1);\n    r1.getRightBottom(x2, y2);\n\n    Rectangle r2(x1+10, y1+10, x2+10, y2+10);\n\n    cout << r1.getArea() << '\\t' << r2.getArea() << endl;\n}\n```\n\n### private & public\n\n정보은닉\n\n![](private.png)\n\ninformation hiding 하는 방법.\n\nprivate는 오직 클래스 내부에서만 접근 가능.\n\n#### Example: 클래스정의\n\n- Rectangle.h\n\n      ```cpp\n      #ifndef Rectangle_h\n      #define Rectangle_h\n\n      class Rectangle {\n          int leftTopX, leftTopY;\n          int rightBottomX, rightBottomY;\n          // 클래스 내부에서 정의된 멤버 함수는 기본적으로 inline함수.\n          void setLeftTop(int x, int y){\n              leftTopX = x;\n              leftTopY = y;\n          }\n          void setRightBottom(int x, int y){\n              rightBottomX = x;\n              rightBottomY = y;\n          }\n\n      public:\n          // 자신의 멤버함수 호출\n          void set(int x1, int y1, int x2, int y2){\n              setLeftTop(x1, y1);\n              setRightBottom(x2, y2);\n          }\n          void getLeftTop(int& x, int& y){\n              x = leftTopX;\n              y = leftTopY;\n          }\n          void getRightBottom(int& x, int& y){\n              x = rightBottomX;\n              y = rightBottomY;\n          }\n\n          int getWidth(){\n              return rightBottomX - leftTopX;\n          }\n          int getHeight(){\n              return rightBottomY - leftTopY;\n          }\n\n          // 별도의 구현 파일을 이용함.\n          int getArea();\n          void moveBy(int deltaX, int deltaY);\n\n      };\n\n      #endif\n      ```\n\n- Rectangle.cpp\n\n  ```cpp\n  #include \"Rectangle.h\"\n\n  // 클래스 멤버 함수를 클래스 외부에 정의하고 있음\n  int Rectangle::getArea(){\n      return getWidth()*getHeight();\n  }\n\n  void Rectangle::moveBy(int deltaX, int deltaY){\n      setLeftTop(leftTopX+deltaX, leftTopY+deltaY);\n      setRightBottom(rightBottomX+deltaX, rightBottomY+deltaY);\n  }\n\n  ```\n\n- RectangleMain.cpp\n\n  ```cpp\n  #include <iostream>\n  #include \"Rectangle.h\"\n  using namespace std;\n\n  int main(){\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      Rectangle r1;\n      r1.set(x1, y1, x2, y2);\n\n      int x3, y3, x4, y4;\n      r1.getLeftTop(x3, y3); // x3는 leftTopX랑 연결되어있고, y3는 leftTopY랑 연결되어있음\n      r1.getRightBottom(x4, y4);\n\n\n      Rectangle r2;\n      r2.set(x3, y3, x4, y4);\n      // LeftTopX, LeftTopY, rightBottomX, rightBottomY랑 연결되어있는 x3, y3, x4, y4\n      r2.moveBy(10, 20);\n\n      cout << endl << r1.getArea() << '\\t' << r2.getArea() << endl;\n\n  }\n\n  ```\n\n## Data members and Member function\n\n### 객체의 동적 생성\n\n- 방법1: [] 사용\n\n  ```cpp\n  #include <iostream>\n  #include \"Rectangle.h\"\n  using namespace std;\n\n  int main(){\n      int rectNo;\n      cin >> rectNo;\n      Rectangle* const rectangles = new Rectangle[rectNo];\n\n      for (unsigned int i=0; i<rectNo; i++){\n          cout << \"Enter Rectangle information\" << endl;\n          int x1, y1, x2, y2;\n          cin >> x1 >> y1 >> x2 >> y2;\n          rectangles[i].set(x1, y1, x2, y2);\n      }\n      int totalArea = 0;\n      for (unsigned int i=0; i<rectNo; i++){\n          totalArea += rectangles[i].getArea();\n      }\n\n      delete [] rectangles;\n      cout << \"The total area: \" << totalArea << endl;\n  }\n\n  ```\n\n  ![](newRectangle.png)\n\n- 방법2: 포인터 사용\n\n## Static data member and static member function\n\n## const member function\n\n## Self reference: this\n\n## Nested classes\n\n## New features on classes since c++11\n","excerpt":"클래스 = 객체들의 집합 구조 Example: Rectangle 클래스 private & public 정보은닉  information hiding 하는 방법. private는 오직 클래스 내부에서만 접근 가능. Example: 클래스정의 Rectan…","fields":{"slug":"/cppClasses_1/"},"frontmatter":{"date":"Apr 09, 2021","title":"c++ Classes, Definition of Classes","tags":["c++"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 안드로이드의 이해\n\n- 스마트폰의 대중화\n\n  구글의 안드로이드 - 오픈(open)을 통해 스마트폰 대중화\n\n  => 많은 제조사와 유통사와 연결되었다.\n\n  앱스토어, 플래이스토어를 통해 수익창출이 가능해졌다.\n\n- 안드로이드의 특징\n\n  **오픈소스**\n\n  - **완벽한 컴포넌트**\n\n  - 자바\n\n  - 쉬운 앱 간 연동\n\n  - 다양한 하드웨어 지원\n\n- 안드로이드 플랫폼 아키텍쳐\n\n  - 리눅스 위에 자바를 쓴다 + 리눅스에서 자바를 사용할 수 있게 하는 런타임\n\n  - 리눅스위에 필요하면 라이브러리를 올릴 수 있음(C 나 C++을 올리곤 함)\n\n  ![](architecture.jpeg)\n\n- 안드로이드 점유율\n\n  - 안드로이드 87.5%, 애플 11.9%\n","excerpt":"안드로이드의 이해 스마트폰의 대중화 구글의 안드로이드 - 오픈(open)을 통해 스마트폰 대중화 => 많은 제조사와 유통사와 연결되었다. 앱스토어, 플래이스토어를 통해 수익창출이 가능해졌다. 안드로이드의 특징 오픈소스 완벽한 컴포넌트 자바 쉬운 앱 …","fields":{"slug":"/android/"},"frontmatter":{"date":"Apr 07, 2021","title":"Android","tags":["Android"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n## 접근제어자\n\n1. private\n\n2. default\n\n3. protected\n\n4. public\n\n### private\n\nprivate가 붙은 변수, 메소드는 해당 클래스에서만 접근 가능.\n\n```java\npublic class AccessModifier {\n    private String secret;\n    private String getSecret(){\n        return this.secret;\n    }\n}\n// secret변수, getSecret매소드는 오직 AccessModifier 클래스에서만 접근 가능\n```\n\n### default\n\n접근제어자를 별도로 설정하지 않는다면, default 접근제어자로 됨.\n\n이는 해당 패키지 내에서만 접근이 가능.\n\n```java\n// AstreetHouse.java\npackage jeonghye.hometown;\n\npublic class AstreetHouse {\n    String ownerName = \"Kim\";\n}\n```\n\n```java\n// BstreetHouse.java\npackage jeonghye.hometown;\n\npublic class BstreetHouse {\n    String ownerName = \"Park\";\n\n    public static void main(String[] args){\n        AstreetHouse aHouse = new AstreetHouse();\n        System.out.pringln(aHouse.ownerName);\n    }\n}\n\n```\n\n### protected\n\n동일 패키지내의 클래스 뿐만아니라 해당 클래스를 상속받은 외부 패키지의 클래스에서 접근 가능\n\n```java\n// AstreetHouse.java\npackage jeonghye.hometown;\n\npublic class AstreetHouse {\n    protected String ownerName = \"park\";\n}\n```\n\n```java\n// JinaPark.java\npackage jeonghye.hometown.person;\n\nimport hometown.AstreetHouse;\n\npublic class JinaPark extends AstreetHouse {\n    public static void main(String[] args){\n        JinaPark jnp = new JinaPark();\n        System.out.println(jnp.ownerName);\n    }\n}\n\n```\n\n### public\n\n어떤 클래스에서라도 접근 가능\n\n```java\npackage jeonghye.house;\n\npublic class AstreetHouse {\n    protected String owner = \"park\";\n    public String info = \"this is public message.\";\n}\n```\n","excerpt":"접근제어자 private default protected public private private가 붙은 변수, 메소드는 해당 클래스에서만 접근 가능. default 접근제어자를 별도로 설정하지 않는다면, default 접근제어자로 됨. 이는 해당 …","fields":{"slug":"/JavaAccessModifier/"},"frontmatter":{"date":"Apr 06, 2021","title":"Java, Access Modifier(접근제어자)","tags":["Java"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Q1.4 IAS\n\n![](computer_assgin1_2.png)\n\n명령어는 08A -> 08B -> 08C 순서대로 읽어진다.\n\n08A : 010FA210FB\n08B : 010FA0F08D\n08C : 020FA210FB\n\nIAS의 메모리는 총 40bits로 이뤄져있다.\n명령어는 left, right으로 나눠서 두개가 들어가 있고\n각 instruction은 opconde 8비트와 address 12비트로 나눠졌다.\n\n(opcode + address) + (opcode + address)\n\n위의 명령어(instruction)을 해석해보면\n\n010FA210FB\n\n= (01 + 0FA) + (21 + 0FB)\n\n010FA0F08D\n\n= (01 + 0FA) + (0F + 08D)\n\n020FA210FB\n\n= (02 + 0FA) + (21 + 0FB)\n\n## 16비트로 주어진 opcode를 이진수로 바꿔서 확인\n\nopcode : 01, 02, 21, 0F\n\n01 = 0000 0001 = LOAD M(X)\n\n02 = 0000 0010 = LOAD -M(X)\n\n21 = 0010 0001 = STOR M(X)\n\n0F = 0000 1111 = JUMP+ M(X,0:19)\n\n## 해석\n\n1. LOAD M(0FA) : Transfer M(X) to the accumulator\n\n0FA에 있는 값을 accumulator에 복사.\n\n2. STOR M(0FB) : Transfer contents of accumulator to memory location X\n\naccumulator에 있는 값을 0FB 메모리에 저장.\n\n3. LOAD M(0FA) : Transfer M(X) to the accumulator\n\n0FA에 있는 값을 accumulator에 복사.\n\n4. JUMP+ M(08D,0:19) : If number in the accumulator is nonnegative, take next instruction from left half of M(X)\n\naccumulator안의 값이 음수가 아니라면, 다음 명령어 08D의 왼쪽부터 실행해라.\n\n5. LOAD -M(0FA) : Transfer -M(X) to the accumulator\n\n(음수가 아닐때(0과 양수일때)는 이 5,6번째 명령어가 실행되지 않음 = 양수와 0일때 이 명령어가 실행됨)\n\n0FA에 있는 값에 -를 붙여서 accumulator에 복사.\n\n6. STOR M(0FB) : Transfer contents of accumulator to memory location X\n\naccumulator에 있는 값을 0FB 메모리에 저장.\n\n## 결론\n\naddress 0FA 안에 있는 값을 절대값을 취해 address 0FB에 넣는 과정의 코드\n","excerpt":"Q1.4 IAS  명령어는 08A -> 08B -> 08C 순서대로 읽어진다. 08A : 010FA210FB\n08B : 010FA0F08D\n08C : 020FA210FB IAS의 메모리는 총 40bits로 이뤄져있다.\n명령어는 left, right으…","fields":{"slug":"/computerAssign_1/"},"frontmatter":{"date":"Mar 28, 2021","title":"Computer Architecture(컴퓨터구조), Assign1","tags":["컴퓨터구조","Assign"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Kali Linux 설치\n\n## 1. VirtualBox 설치\n\n다운받기 -> [VirtualBox downloads](https://www.virtualbox.org/wiki/Downloads)\n\n다운된 dmg 파일 실행\n\n![](virtualBoxInstaller.png)\n\n<br/>\n\n## 2. Kali Linux 설치\n\n이미지로 설치 -> [Kali downloads](https://www.kali.org/downloads/)\n\n![](downloadBtn.png)\n\nOffensive Security VM Download Page 누르기\n\n<br/>\n\n![](imageDownloadBtn.png)\n\nKALI LINUX VIRTUALBOX IMAGES 클릭\n\n<br/>\n\n## 3. 이미지 가져오기\n\n![](import.png)\n\n가져오기 클릭! > 동의합니다\n\n<br/>\n\n## 4. 설정(1) : 포트 > USB\n\n![](usbPort.png)\n\n'USB 1.1(OHCI) 컨트롤러' 선택\n\n<br/>\n\n## 4. 설정(2) : 네트워크 > 어댑터1\n\n![](networkSetting.png)\n\n- 브리지 : 지금 사용하고 있는 네트워크를 같이 사용.\n\n- NAT : VirtualBox 내부에 또다른 네트워크를 만들어서 아이피를 할당.\n\n네트워크 브릿지를 연결해주면, 와이파이에 연결된 모든 기기가 이 칼리리눅스에 연결할 수 있다.\n\n<br/>\n\n## 실행\n\n에러발생\n\n해결 => [Error Kernel driver not installed](https://jeonghye-choi.github.io/VirtualBoxError/)\n\n![](success.png)\n\n초기 아이디 kali 비번 kali\n\n![](success2.png)\n\n실행!!\n\n<br/>\n<br/>\n\n# Kali Linux 환경설정\n\n## 0. Terminal Emulator 클릭\n\n![](terminalEmulator.png)\n\n<br/>\n\n## 1. 네트워크 연결 확인\n\n```\n$ ifconfig\n```\n\n![](ifconfig.png)\n\neth0에 inet 확인.\n\n<br/>\n\n```\n$ clear\n```\n\n![](clear.png)\n\n화면 깨끗!\n\n<br/>\n\n## 2. 데이터 정상적으로 나가는 지 확인\n\n```\n$ ping 8.8.8.8\n```\n\n![](ping8888.png)\n\n![](ping8888result2.png)\n\n확인 후 ctrl+c 눌러서 중단하기\n\n<br/>\n\n## 3. Kali Linux의 root계정 관리자 권한(최고권한)으로 바꾸기\n\nroot는 리눅스에서 최고권한 (관리자 권한)\n\n```\n$ sudo su -\n```\n\n![](sudoresult.png)\n\n초기 비밀번호 'kali' 입력\n\n비밀번호가 안보이는 건 정상이다. 화면에 나오지 않을 뿐 입력되고 있음.\n\n![](root.png)\n\nkali -> root, \\$ -> # 로 변경됐다.\n\n![](root2.png)\n\n<br/>\n\n## 4. 비밀번호 변경\n\n```\n# passwd\n```\n\n![](passwdresult2.png)\n\n새로운 비번 입력 -> 다시 입력 -> 성공!\n\n<br/>\n\n## 5. 업데이트\n\n```\n# apt-get update\n```\n\n![](update.png)\n\n<br/>\n\n## 세팅끝!!\n\nKali Linux 종료\n\n```\n# poweroff\n```\n\n<br/>\n\n아이디 root 비번 (새로 설정한 비밀번호)\n\n![](rootLogin.png)\n","excerpt":"Kali Linux 설치 1. VirtualBox 설치 다운받기 -> VirtualBox downloads 다운된 dmg 파일 실행  2. Kali Linux 설치 이미지로 설치 -> Kali downloads  Offensive Security V…","fields":{"slug":"/installKaliLinux/"},"frontmatter":{"date":"Mar 26, 2021","title":"Kali Linux 설치 & 환경설정","tags":["VirtualBox","Kali Linux","해킹"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n![](KernelDriverError.png)\n\n<br/>\n\n맥에서는 모르는 프로그램에 대해 실행 권한이 필요하다.\n권한을 주지 않았을 때, 커널쪽에서 처리하지 못해서 생기는 오류라고 한다.\n\n즉, 시스템 바닥까지 가서 처리해야하는데 그러지 못해서 생긴 에러다.\n\n해결방법은, 이걸 실행하는 곳에서 보안 및 개인정보 보호에서 허용 하면되지만...\n\n![](nothingShow.png)\n\n아무것도 안보임..!!\n\n찾아보니까 처음 설치하고 실행했을 때 뜨는데, 그때 30분안에 하지 않으면 안보인다고..\n빅서에게 두번의 기회는 없다고ㅠㅜ\n\n<br/>\n\n## 시도했던 다른 방법들\n\n해결방법을 찾아봤었는데\n\n1 복구모드에서 터미널에 \"curutil disable; reboot\"입력해서 가상머신 다시 설치하기\n\n2 아래 링크에 있는 방법들\n\n(https://medium.com/@DMeechan/fixing-the-installation-failed-virtualbox-error-on-mac-high-sierra-7c421362b5b5)\n\n이 방법들 모두 되지 않았다ㅠㅜ\n\n오라클 프로그램 허용이 이렇게 까다로울 일인가 싶긴하지만 보안을 위한 거라는데 어쩔 수 있나ㅠㅜ\n\n<br/>\n\n## 결국 해결한 방법\n\n돌고돌아 해결한 방법은 VirtualBox를 **\"깨끗하게\"** 지우고 다시 설치하는 것이였다.\n\n### > 1. Uninstall\n\n![](virtualBoxInstaller.png)\n\nVirtualBox 인스톨러를 다운받아서 오른쪽 밑에 있는 \"VirtualBox_Uninstall.tool\"을 더블클릭!\n\n언인스톨러를 사용해서 지워야 깔끔하게 지워진다. 절대로 그냥 휴지통에 넣으면 안된다!! 맥용 클리너보단 이 스크립트를 터미널에서 돌리기를 더 추천!\n\n```\nDo you wish to uninstall VirtualBox (Yes/No)?\nYes\n...\n\nDo you wish to uninstall the FUSE for macOS core package (Yes/No)?\nYes\n...\n\n[프로세스 완료됨]\n```\n\n<br/>\n\n### > 2. 다시 설치\n\n![](reinstall.png)\n\n그래도 아무 것도 안떠서 삭제하고 설치하기를 한 세번정도 반복했다.(더이상은 어떻게 해야할지 모르겠어서..)\n\n그렇게 다시 설치한지 세 번 만에, 보안 및 개인 정보 보호에 '재시동'버튼이 활성화 되었다. (새로운 시스템 확장 프로그램을 사용하기 전에 재시동 해야한다는 말과 함께)\n\n클릭!!\n\n재시동 후 가상머신 부르고 다시 보안 및 개인 정보 보호를 확인하니까 '재시동'버튼이 또 활성화 되어있었다. (개발자 'Oracle America, Inc.'관련 메세지와 함께)\n\n그래서 재시동 후 가상머신 불러오니까 또 에러...(제발ㅠㅜㅠ)\n\n![](error2.png)\n\n### > 3. Install VirtualBox extension\n\n알고보니까 VirtualBox extension을 다시 설치해야했다.\n\n![](extensionInstall.png)\n\n--> [가상머신 사이트](https://www.virtualbox.org/wiki/Downloads)에서 설치.\n\n<br/>\n\n드디어!! 드디어 실행된다!!\n![](success.png)\n\n초기 아이디 kali 비밀번호 kali\n\n![](success2.png)\n\n너무너무 감동스러운 화면><\n\n<br/>\n\n## 후기\n\n해결되고서 생각해보니 그동안 깔끔하게 지우지 않았던게 원인이였던 것 같다. (uninstaller가 괜히 있는게 아닌게지ㅎㅎ)\n\n이 에러는 새로운 분야의 공부를 위한 초기 환경설정 과정에서 만났는데, 첫 한걸음부터 난관이였어서 힘들었지만 그래도 오래걸려도 계속 붙잡고 있었던 보람은 있어서 좋다^^\n\n매번 느끼는 거지만 포기하지만 않으면 아무리 허무한 이유때문이여도 얻는건 분명 있는거 같다:)\n","excerpt":"맥에서는 모르는 프로그램에 대해 실행 권한이 필요하다.\n권한을 주지 않았을 때, 커널쪽에서 처리하지 못해서 생기는 오류라고 한다. 즉, 시스템 바닥까지 가서 처리해야하는데 그러지 못해서 생긴 에러다. 해결방법은, 이걸 실행하는 곳에서 보안 및 개인정…","fields":{"slug":"/VirtualBoxError/"},"frontmatter":{"date":"Mar 26, 2021","title":"\\[Error] Kernel driver not installed (rc=-1908 Mac Big Sur)","tags":["VirtualBox","Error","해킹"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n# Intro\n\nCPU 내부에서는 명령어가 제어신호(Control Signal Specification)로 바껴서 내부에 있는 ALU, Register 같은 구성장치에 의해 해당 명령어가 실행된다.\n\n내부적으로 어떻게 만들어져있고 어떻게 동작하는지에 대한 이해가 컴퓨터 구조!\n\n## 🌀 Category\n\n- [Basic Concepts and Computer Evolution]()\n\n- Performance Issues\n\n- A Top-Level View of Computer Function and Interconnection\n\n- Cache Memory\n\n- Internal Memory Technology\n\n- External Memory\n\n- Input/Output\n\n- Computer Arithmetic\n\n- Processor Structure and Function\n\n- Reduced Instruction Set Computers (RISCs)\n\n- Control Unit Operation\n\n- Instruction-Level Parallelism and Superscalar Processors\n\n- Parallel Processing\n\n- Multicore Computers\n\n- General-Purpose Graphic Processing Units\n","excerpt":"Intro CPU 내부에서는 명령어가 제어신호(Control Signal Specification)로 바껴서 내부에 있는 ALU, Register 같은 구성장치에 의해 해당 명령어가 실행된다. 내부적으로 어떻게 만들어져있고 어떻게 동작하는지에 대한 …","fields":{"slug":"/ComputerArchitecture/"},"frontmatter":{"date":"Mar 24, 2021","title":"Computer Architecture(컴퓨터구조), Intro","tags":["컴퓨터구조"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n```bash\n$ git push --set-upstream origin master\n\n! [rejected] master -> master (non-fast-forward)\nerror: failed to push some refs to 'https://github.com/SOMJANG-42MARU/MaruKeyword.git'\nhint: Updates were rejected because the tip of your current branch is behind\nhint: its remote counterpart. Integrate the remote changes (e.g.\nhint: 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n업로드하려는 디렉토리에서\n\n```bash\n$ git init   # 초기화\n```\n\n```bash\n$ git remote add origin <url>   # 원격저장소 설정\n```\n\n```bash\n$ git push origin master   # ERROR!!!!\n```\n\n<br/>\n\n## 원인\n\n.gitignore 파일 또는 README.md 파일로 인해 발생\n\n<br/>\n\n## 해결방법\n\npush하려고 하는 브랜치 앞에 +를 붙여 push\n\n```bash\n$ git push origin +master\n```\n\npush 성공!\n\n<br/>\n\n## 참고\n\n- [솜씨좋은장씨 유용한정보 참고](https://somjang.tistory.com/entry/Git-rejected-master-master-non-fast-forward-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95)\n","excerpt":"업로드하려는 디렉토리에서 원인 .gitignore 파일 또는 README.md 파일로 인해 발생 해결방법 push하려고 하는 브랜치 앞에 +를 붙여 push push 성공! 참고 솜씨좋은장씨 유용한정보 참고","fields":{"slug":"/gitNonFastForward/"},"frontmatter":{"date":"Mar 21, 2021","title":"\\[Error] ![rejected] master -> master (non-fast-forward)","tags":["git","Error"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n```bash\n$ git push\n\n# error\nfatal: The current branch master has no upstream branch.\n\nTo push the current branch and set the remote as upstream, use\n\ngit push --set-upstream origin master\n```\n\n<br/>\n\n## 원인\n\n원격저장소 이름을 정확히 언급해주지 않아서.\n\n## 해결방법\n\ngit remote -v 를 통해 현재 저장된 원격 저장소 이름을 찾고,\n\n원격 저장소를 명시하여 적어주기! (\"origin\")\n\n```bash\n$ git remote -v\n\n$ git push origin master\n```\n","excerpt":"원인 원격저장소 이름을 정확히 언급해주지 않아서. 해결방법 git remote -v 를 통해 현재 저장된 원격 저장소 이름을 찾고, 원격 저장소를 명시하여 적어주기! (\"origin\")","fields":{"slug":"/gitCurrentBranch/"},"frontmatter":{"date":"Mar 21, 2021","title":"\\[Error] The current branch master has no upstream branch","tags":["git","Error"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n민감한 정보가 푸시(push)되어 GitHub에 업로드 되어버리면, 해당부분만 삭제하거나 수정하기 어렵다.\n\n이럴때 현재 commit을 취소하고 취소한 히스토리까지를 서버에 강제 push하는 방법이 있다.\n\n<br/>\n\n## 최근 commit취소하고 강제 push\n\n현재 올라간 commit 내용을 로컬 작업 패널에서 되돌리고,\n\n다시 서버로 commit. 이 방법을 시행하기 위해 개발자의 작업 내용을 서버상에 강제로 덮어쓰게 되므로 이후 작업했거나 다른 사람의 commit 내용이\n지워질 수 있기에 신중해야한다.\n\n먼저 작업 디렉토리로 이동해 다음 명령어를 입력한다.\n\n```bash\n$ git reset HEAD^  # 마지막에 실행한 커밋 내용을 되돌림\n```\n\n커밋하고\n\n```bash\n$ git commit -m \"커밋 메시지\"\n```\n\n푸시\n\n```bash\n$ git push origin master -f (또는 git push origin +master)\n```\n\n<br/>\n\n## commit history 모두 삭제하고 초기 상태로 되돌리기\n\n히스토리를 모두 지우고 싶은 경우.\n\n- 경고: 이 방법을 사용하면 레포에 있는 모든 파일과 커밋 히스토리가 삭제! 현재 작업 디렉토리에서 initial commit\n  상태로 업로드 됨.\n\n먼저 현재 작업 디렉토리(.git 이 존재하는 위치)에서 다음 명령어 입력\n\n```bash\n$ rm -rf .git\n```\n\n그리고 git init 명령어로 초기화하고 git add 로 파일을 추가(Staging)하기\n\n```bash\n$ git init\n$ git add . (또는 git add -A)\n```\n\n```bash\n$ git commit -m \"initial commit\"\n$ git remote add origin <저장소 URL>\n```\n\n기존 push할 때와 다르게 --force 명령어를 덧붙여준다. 이미 서버에 존재하는 파일로 인해\n발생하는 에러 메세지를 무시하고 강제로 push하겠다는 의미.\n\n```bash\n$ git push -u --force origin master\n```\n\n<br/>\n\n### 참고\n\n- [JooTC (커밋 히스토리 삭제하여 다시 푸쉬하기)](https://jootc.com/p/201909143109)\n","excerpt":"민감한 정보가 푸시(push)되어 GitHub에 업로드 되어버리면, 해당부분만 삭제하거나 수정하기 어렵다. 이럴때 현재 commit을 취소하고 취소한 히스토리까지를 서버에 강제 push하는 방법이 있다. 최근 commit취소하고 강제 push 현재 …","fields":{"slug":"/gitCommitHistory/"},"frontmatter":{"date":"Mar 21, 2021","title":"git 커밋 히스토리 삭제","tags":["git"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n> ### Q1. How many paths from (2,1) to (7,4) in the xy-plane?\n\n![](Q1_Img.png)\n\n=> **Permutation**\n\n> ### Q2. Do any tow people in Busan have the same number of hairs on their head?\n>  - A typical human head has an average of around 150,000 hairs, it is reasonable to assume (as an upper bound) that no one has more than 1,000,000 hairs on their head\n>  - The population of Busan is about 3.4 millions\n>> Q2. In this problem, what is 'pigeon'? 'hole'?\n\nhole : 머리카락 갯수, pigeon : 사람 수\n\n- number of holes = 1,000,000\n\n- number of pigeons = 3,400,000\n\n=> 따라서, 머릿카락이 같은 사람이 있을 수 밖에 없다\n\n<br/>\n\n# Principle of Counting\n\n## Rules of Sum and Product\n\n### 1. Rules of Sum\n\nm가지 방법으로 실행되는 일과 n가지 방법으로 실행되는 일이 동시에 발생하지 않는다면, \n일을 수행할 방법은 m+n가지 이다.\n\nfirst task can be performed in **\"m\"** ways(1), while a second task in **\"n\"** ways(2), and the two tasks **cannot** be performed **simultaneously**(3)\n\nthen, **performing either task** can be accomlished **in any one of m + n ways**\n\n![](sum_Img.png)\n\n> Q4. Travel Options\n> - You need to travel in between city A and B.\n> - You can either fly, take a train, or a bus.\n> - There are 12 different flight in between A and B, 5 different trains and 10 buses.\n> - How many options do you have to get from A to B?\n> => 12 + 5 + 10 = 27\n\n> Q5. # of Possible Password\n> - The minimul length of the password is 1 and the maximum is 3.\n> - The password can consist of only the uppercase letters (A~Z).\n> - How many cases are there for the possible password?\n> => 26 + 26x26 + 26x26x26 = 18,278\n\n\n### 2. Rule of Product\n\n순서가 있는데, 첫번째는 m개의 가능한 방법이 있고, 두번째는 n개의 가능한 방법이 있다. 전체 가능한 절차는 \n총 mxn 가지 이다.\n\nIf a procedure can be broken down into first & second stages(1),\n\nand if there are **m possible outcomes** for the first stage(2) and\n\nif, for each of these outcomes, there are **n possible outcomes** for the second stage(3), then the total procedure can be carried out, in the designated order, **in mxn ways**\n\n![](product_Img.png)\n\n\n> Q6. How many different bit strings of length 7 are there? (for example, 1011010)\n> => 2^7 = 128\n\n> Q7. The license plate of the car is consisted of two alphabet letters followed by four digits\n> => 26x26x10^4 = 676x10^4\n\n\n## Permutations (순열)\n\n\\#arrangement \\#order\n\n순서를 가지고 나열!\n\n![](permutations_Img.png)\n\n> Q8. The number of permutaions of the letters in the word \"COMPUTER\"\n> => 8!\n\n\n> Q9. If only five of the letters are used\n> => 8C5 x 5!\n\n> Q10. If 'C' and 'O' should be \n\n\n\n\n## Combinations : Binomial Theorem\n\n\n\n## Combinations with Repetition\n\n\n\n\n## Pigeonhole Principle\n\n","excerpt":"Q1. How many paths from (2,1) to (7,4) in the xy-plane?  => Permutation Q2. Do any tow people in Busan have the same number of hairs on the…","fields":{"slug":"/Counting_1/"},"frontmatter":{"date":"Mar 08, 2021","title":"Discrete Mathematics, Counting(1)","tags":["이산수학"],"update":"Jan 01, 0001"}}},{"node":{"rawMarkdownBody":"\n이산수학은 이산적인 수학 구조에 대해 연구하는 학문이다.\n연속되지 않는 공간을 다루는 데, 유한수학이라고도 하며, 전산학적인 측면을 강조할 때는 전산수학이라고도 한다. 주로 정수, 유한 그래프, 형식 언어 같이 가산집합(countable set)에 속하는 개념을 다룬다.\n<br/>\n\n# Intro\n\n## 🌀 Category\n\n- [Principle of Counting]()\n\n- [Logic: Propositional Calculus]()\n\n- Logic: Formal Proof in proposition Calculus\n- Logic: Predicate Calculus\n- Logic: Formal Proof in Predicate Calculus\n\n- Properties of Integer and Mathematical Induction\n- Chinese Remainder Theorem\n- Set Theory\n\n- Relations and Functions\n- Properties of Relations, Relations and directed graphs\n- Equivalence Relations: equivalent classes partition, refinement\n\n- Ordering Relations: poset\n- Ordering Relations: bounds, lattices\n\n<br/>\n\n## 🌀 Mathematics\n\n### Foundation & Philosophy\n\n**: 수학 기초론 (Logic)**\n\n- Mathematical Logic / Formal Logic (수리논리학/ 형식논리학)\n\n- Set Theory (집합론)\n\n- Category Theory (범주론)\n\n- Theory of Computation (계산이론)\n\n\n### Pure Mathematics\n\n#### 1. **Quantity - Arithmetic(산술)**\n    \n- Natural Numbers(자연수): N\n\n- Integers(정수): Z\n\n- Rational Numbers(유리수): Q\n\n- Real Numbers(실수): R\n\n- Complex Numbers(복소수)\n\n> ### Q2. What is symbol for the Natural Numbers? - N\n\n\n#### 2. 🌟 **Structure - Algebra(대수학)**\n\n=> 이산수학의 Main Contents\n\n代(대신하다 대) 1, 2, ... , x, y, z\n\n- Combinatorics(조합론)\n\n    - 순열, 조합\n\n- Number Theory(수론)\n\n- Group Theory(군론)\n\n- Graph Theory(그래프 이론)\n\n- Order Theory(순서론)\n\n#### 3. **Space - Geometry(기하학)**\n\n- Trigonometry(삼각법/삼각함수)\n\n- Differential Geometry(미분기하학)\n\n- Topology(위상수학)\n\n- Fractal Geometry(프랙탈 기하학)\n\n\n#### 4. **Change - Analysis(해석학)**\n\n변화를 다루는 것\n\n- Calculus(미적분학)\n\n- Vector Calculus(벡터 미적분학)\n\n- Differential Equations(미분방정식)\n\n- Dynamical System(동역학계)\n\n- Chaos Theory(혼돈이론)\n\n\n### Applied Mathematics\n\n: Statistics, Decision Sciences and Computational Mathematics\n\n- Probability Theory(확률론)\n\n- Statistics(통계학)\n\n- Numerical Analysis(수치해석)\n\n- Optimization(최적화 이론)\n\n- Mathematical Finance(금융수학)\n\n- Game Theory(게임 이론)\n\n- Control Theory(제어 이론)\n\n- Cryptography(암호학)\n\n- Mathematical Physics(수리물리학)\n\n- Fluid Dynamics(유체역학)\n\n<br/>\n\n## 🌀 Discrete Mathematics\n\n이산적인 수학 구조에 대해 연구하는 학문.\n\n연속되지 않는 공간을 다루는 데, 유한수학이라고도 하며, 전산학적인 측면을 강조할 때는 전산수학이라고도 한다.\n\n주로 정수, 유한 그래프, 형식 언어 같이 가산집합(countable set)에 속하는 개념을 다룬다.\n\n이산수학은 전산학의 기초가 되는데, 이것은 컴퓨터에서 다루는 자료형이 이산적이라는 것에서 기안한다. 이산수학에서 나온 개념과 기호는 컴퓨터알고리즘과 프로그래밍 언어의 문제나 대상들을 연구하는 데 유용하다.\n\n> ### Q3. 이산수학을 영어로? - Discrete Mathematics\n\n### 이산수학의 주제\n\n- 조합론 : Combinatorics\n\n- 논리학: Logic\n\n- 집합론: Set Theory\n\n- 관계론: Relation Algebra\n\n- 그래프 이론: Graph Theory\n\n- 수론: Number Theory\n    - 암호학: Cryptography\n\n- 오토마타: Automata Theory","excerpt":"이산수학은 이산적인 수학 구조에 대해 연구하는 학문이다.\n연속되지 않는 공간을 다루는 데, 유한수학이라고도 하며, 전산학적인 측면을 강조할 때는 전산수학이라고도 한다. 주로 정수, 유한 그래프, 형식 언어 같이 가산집합(countable set)에 …","fields":{"slug":"/DiscreteMathematics/"},"frontmatter":{"date":"Mar 03, 2021","title":"Discrete Mathematics(이산수학), Intro","tags":["이산수학"],"update":"Jan 01, 0001"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977","694178885"]}